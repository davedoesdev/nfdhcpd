#!/usr/bin/env python
#

# nfdcpd: A promiscuous, NFQUEUE-based DHCP server for virtual machine hosting
# Copyright (c) 2010 GRNET SA
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

import os
import re
import sys
import glob
import time
import logging
import logging.handlers
import threading
import traceback
import subprocess

import daemon
import daemon.pidlockfile
import nfqueue
import pyinotify

import IPy
import socket
from select import select
from socket import AF_INET, AF_INET6

from scapy.data import ETH_P_ALL
from scapy.packet import BasePacket
from scapy.layers.l2 import Ether
from scapy.layers.inet import IP, UDP
from scapy.layers.inet6 import IPv6, ICMPv6ND_RA, ICMPv6ND_NA, \
                               ICMPv6ND_NS, \
                               ICMPv6NDOptDstLLAddr, \
                               ICMPv6NDOptPrefixInfo, \
                               ICMPv6NDOptRDNSS
from scapy.layers.dhcp import BOOTP, DHCP
from scapy.layers.dns import DNS, DNSQR, DNSRR
import scapy.layers.dns as scapy_dns

DEFAULT_CONFIG = "/etc/nfdhcpd/nfdhcpd.conf"
DEFAULT_PATH = "/var/run/ganeti-dhcpd"
DEFAULT_USER = "nobody"
DEFAULT_LEASE_LIFETIME = 604800 # 1 week
DEFAULT_LEASE_RENEWAL = 600  # 10 min
DEFAULT_RA_PERIOD = 300 # seconds
DEFAULT_DNS_TTL = 10 # seconds
DEFAULT_DNS_FORWARD = False

LOG_FILENAME = "nfdhcpd.log"

SYSFS_NET = "/sys/class/net"

LOG_FORMAT = "%(asctime)-15s %(levelname)-6s %(message)s"

# Configuration file specification (see configobj documentation)
CONFIG_SPEC = """
[general]
pidfile = string()
datapath = string()
logdir = string()
user = string()

[dhcp]
enable_dhcp = boolean(default=True)
lease_lifetime = integer(min=0, max=4294967295)
lease_renewal = integer(min=0, max=4294967295)
server_ip = ip_addr(default=None)
dhcp_queue = integer(min=0, max=65535)
nameservers = ip_addr_list(family=4, default=None)
domain = string(default=None)

[ipv6]
enable_ipv6 = boolean(default=True)
ra_period = integer(min=1, max=4294967295)
rs_queue = integer(min=0, max=65535)
ns_queue = integer(min=0, max=65535)
nameservers = ip_addr_list(family=6, default=None)

[dns]
enable_dns = boolean(default=False)
dns_queue = integer(min=0, max=65535)
dns6_queue = integer(min=0, max=65535)
server_ip = ip_addr(default=None)
server_ip6 = ip6_addr(default=None)
ttl = integer(min=0, max=2147483647, default=10)
forward = boolean(default=False)

[addresses]

[addresses6]
"""


DHCPDISCOVER = 1
DHCPOFFER = 2
DHCPREQUEST = 3
DHCPDECLINE = 4
DHCPACK = 5
DHCPNAK = 6
DHCPRELEASE = 7
DHCPINFORM = 8

DHCP_TYPES = {
    DHCPDISCOVER: "DHCPDISCOVER",
    DHCPOFFER: "DHCPOFFER",
    DHCPREQUEST: "DHCPREQUEST",
    DHCPDECLINE: "DHCPDECLINE",
    DHCPACK: "DHCPACK",
    DHCPNAK: "DHCPNAK",
    DHCPRELEASE: "DHCPRELEASE",
    DHCPINFORM: "DHCPINFORM",
}

DHCP_REQRESP = {
    DHCPDISCOVER: DHCPOFFER,
    DHCPREQUEST: DHCPACK,
    DHCPINFORM: DHCPACK,
    }


def parse_routing_table(table="main", family=4):
    """ Parse the given routing table to get connected route, gateway and
    default device.

    """
    ipro = subprocess.Popen(["ip", "-%d" % family, "ro", "ls",
                             "table", table], stdout=subprocess.PIPE)
    routes = ipro.stdout.readlines()

    def_gw = None
    def_dev = None
    def_net = None

    for route in routes:
        match = re.match(r'^default.*via ([^\s]+).*dev ([^\s]+)', route)
        if match:
            def_gw, def_dev = match.groups()
            break

    for route in routes:
        # Find the least-specific connected route
        m = re.match("^([^\\s]+) dev %s" % def_dev, route)
        if not m:
            continue

        if family == 6 and m.group(1).startswith("fe80:"):
            # Skip link-local declarations in "main" table
            continue

        def_net = m.group(1)

        try:
            def_net = IPy.IP(def_net)
        except ValueError, e:
            logging.warn("Unable to parse default route entry %s: %s",
                         def_net, str(e))

    return Subnet(net=def_net, gw=def_gw)


def parse_binding_file(path):
    """ Read a client configuration binding file

    """
    try:
        iffile = open(path, 'r')
    except EnvironmentError, e:
        logging.warn("Unable to open binding file %s: %s", path, str(e))
        return None

    try:
        mac = None
        ips = None
        link = None
        hostname = None
        subnet = None
        gateway = None
        subnet6 = None
        gateway6 = None
        dhcp_server_ip = None
        dns_server_ip = None
        dns_server_ip6 = None
        nameservers = None
        nameservers6 = None
        domain = None
        dns_ttl = None
        dns_forward = None
        addresses = {}
        addresses6 = {}
        address_lists = []

        for line in iffile:
            if line.startswith("#"):
                continue
            elif line.startswith("IP="):
                ip = line.strip().split("=")[1]
                ips = ip.split()
            elif line.startswith("MAC="):
                mac = line.strip().split("=")[1]
            elif line.startswith("LINK="):
                link = line.strip().split("=")[1]
            elif line.startswith("HOSTNAME="):
                hostname = line.strip().split("=")[1]
            elif line.startswith("SUBNET="):
                subnet = line.strip().split("=")[1]
            elif line.startswith("GATEWAY="):
                gateway = line.strip().split("=")[1]
            elif line.startswith("SUBNET6="):
                subnet6 = line.strip().split("=")[1]
            elif line.startswith("GATEWAY6="):
                gateway6 = line.strip().split("=")[1]
            elif line.startswith("DHCP_SERVER_IP="):
                dhcp_server_ip = line.strip().split("=")[1]
            elif line.startswith("DNS_SERVER_IP="):
                dns_server_ip = line.strip().split("=")[1]
            elif line.startswith("DNS_SERVER_IP6="):
                dns_server_ip6 = line.strip().split("=")[1]
            elif line.startswith("NAMESERVERS="):
                nameservers = line.strip().split("=")[1]
                nameservers = [ns.strip() for ns in nameservers.split(",")]
            elif line.startswith("NAMESERVERS6="):
                nameservers6 = line.strip().split("=")[1]
                nameservers6 = [ns.strip() for ns in nameservers6.split(",")]
            elif line.startswith("DOMAIN="):
                domain = line.strip().split("=")[1]
            elif line.startswith("DNS_TTL="):
                dns_ttl = int(line.strip().split("=")[1])
            elif line.startswith("DNS_FORWARD="):
                dns_forward = line.strip().split("=")[1].lower()
                dns_forward = (dns_forward == "true") or (dns_forward == "yes")
            elif line.startswith("ADDRESS:"):
                entry = line[8:].strip().split("=")
                addresses[entry[0]] = entry[1]
            elif line.startswith("ADDRESS6:"):
                entry = line[9:].strip().split("=")
                addresses6[entry[0]] = entry[1]
            elif line.startswith("ADDRESS_LISTS:"):
                address_lists = line.strip().split("=")[1]
                address_lists = [al.strip() for al in address_lists.split(",")]
            else:
                logging.warn("Unknown line in binding file %s: %s" %
                             (path, line))

        return Client(mac=mac, ips=ips, link=link, hostname=hostname,
                      subnet=subnet, gateway=gateway,
                      subnet6=subnet6, gateway6=gateway6,
                      dhcp_server_ip=dhcp_server_ip, nameservers=nameservers,
                      nameservers6=nameservers6, domain=domain,
                      dns_server_ip=dns_server_ip,
                      dns_server_ip6=dns_server_ip6,
                      addresses=addresses, addresses6=addresses6,
                      dns_ttl=dns_ttl, dns_forward=dns_forward,
                      address_lists=address_lists)
    finally:
        iffile.close()

def parse_address_list_file(path):
    """ Read an address list file

    """
    try:
        alfile = open(path, 'r')
    except EnvironmentError, e:
        logging.warn("Unable to open address list file %s: %s", path, str(e))
        return None

    try:
        addresses = {}
        addresses6 = {}

        for line in alfile:
            if line.startswith("#"):
                continue
            elif line.startswith("ADDRESS:"):
                entry = line[8:].strip().split("=")
                addresses[entry[0]] = entry[1]
            elif line.startswith("ADDRESS6:"):
                entry = line[9:].strip().split("=")
                addresses6[entry[0]] = entry[1]
            else:
                logging.warn("Unknown line in address list file %s: %s" %
                             (path, line))

        return AddressList(addresses=addresses, addresses6=addresses6)

    finally:
        alfile.close()

class ClientFileHandler(pyinotify.ProcessEvent):
    def __init__(self, server):
        pyinotify.ProcessEvent.__init__(self)
        self.server = server

    def process_IN_DELETE(self, event): # pylint: disable=C0103
        """ Delete file handler

        Currently this removes an interface from the watch list

        """
        self.server.remove_iface(event.name)

    def process_IN_CLOSE_WRITE(self, event): # pylint: disable=C0103
        """ Add file handler

        Currently this adds an interface to the watch list

        """
        self.server.add_iface(os.path.join(event.path, event.name))

    def process_IN_Q_OVERFLOW(self, event): # pylint: disable=C0103
        """ Event overflow handler

        Currently this reads all interface configs

        """
        for path in glob.glob(os.path.join(self.server.data_path, "*")):
            self.server.add_iface(path)


class Client(object):
    def __init__(self, mac=None, ips=None, link=None, hostname=None,
                 subnet=None, gateway=None, subnet6=None, gateway6=None,
                 dhcp_server_ip=None, nameservers=None, nameservers6=None,
                 domain=None, dns_server_ip=None, dns_server_ip6=None,
                 dns_ttl=None, dns_forward=None, addresses={}, addresses6={},
                 address_lists=[]):
        self.mac = mac
        self.ips = ips
        self.hostname = hostname
        self.link = link
        self.subnet = subnet
        self.gateway = gateway
        self.subnet6 = subnet6
        self.gateway6 = gateway6
        self.dhcp_server_ip = dhcp_server_ip
        self.dns_server_ip = dns_server_ip
        self.dns_server_ip6 = dns_server_ip6
        self.dns_ttl = dns_ttl
        self.dns_forward = dns_forward
        self.nameservers = nameservers
        self.nameservers6 = nameservers6
        self.domain = domain
        self.addresses = addresses
        self.addresses6 = addresses6
        self.address_lists = address_lists
        self.iface = None

    @property
    def ip(self):
        return self.ips[0]

    def is_valid(self):
        return self.mac is not None

class AddressList(object):
    def __init__(self, addresses={}, addresses6={}):
        self.addresses = addresses
        self.addresses6 = addresses6

def make_eui64(net, mac):
    """ Compute an EUI-64 address from an EUI-48 (MAC) address

    """
    comp = mac.split(":")
    prefix = IPy.IP(net).net().strFullsize().split(":")[:4]
    eui64 = comp[:3] + ["ff", "fe"] + comp[3:]
    eui64[0] = "%02x" % (int(eui64[0], 16) ^ 0x02)
    for l in range(0, len(eui64), 2):
        prefix += ["".join(eui64[l:l+2])]
    return IPy.IP(":".join(prefix))

def make_ll64(mac):
    """ Compute an IPv6 Link-local address from an EUI-48 (MAC) address

    """
    return make_eui64("fe80::", mac)


class Subnet(object):
    def __init__(self, net=None, gw=None):
        if isinstance(net, str):
            try:
                self.net = IPy.IP(net)
            except ValueError, e:
                logging.warn("Error parsing subnet %s: %s", net, str(e))
                self.net = None
        else:
            self.net = net
        self.gw = gw

    @property
    def netmask(self):
        """ Return the netmask in textual representation

        """
        return str(self.net.netmask())

    @property
    def broadcast(self):
        """ Return the broadcast address in textual representation

        """
        return str(self.net.broadcast())

    @property
    def prefix(self):
        """ Return the network as an IPy.IP

        """
        return self.net.net()

    @property
    def prefixlen(self):
        """ Return the prefix length as an integer

        """
        return self.net.prefixlen()

    def make_eui64(self, mac):
        """ Compute an EUI-64 address from an EUI-48 (MAC) address in this
        subnet.

        """
        return make_eui64(self.net, mac)


class VMNetProxy(object): # pylint: disable=R0902
    def __init__(self, data_path, dhcp_queue_num=None, # pylint: disable=R0913
                 rs_queue_num=None, ns_queue_num=None,
                 dns_queue_num=None, dns6_queue_num=None,
                 dhcp_lease_lifetime=DEFAULT_LEASE_LIFETIME,
                 dhcp_lease_renewal=DEFAULT_LEASE_RENEWAL,
                 dhcp_domain='',
                 dhcp_server_ip=None, dhcp_nameservers=None,
                 ra_period=DEFAULT_RA_PERIOD, ipv6_nameservers=None,
                 dns_server_ip=None,
                 dns_server_ip6=None,
                 dns_ttl=DEFAULT_DNS_TTL,
                 dns_forward=DEFAULT_DNS_FORWARD,
                 addresses={}, addresses6={}):

        self.data_path = data_path
        self.lease_lifetime = dhcp_lease_lifetime
        self.lease_renewal = dhcp_lease_renewal
        self.dhcp_domain = dhcp_domain
        self.dhcp_server_ip = dhcp_server_ip
        self.dns_server_ip = dns_server_ip
        self.dns_server_ip6 = dns_server_ip6
        self.dns_ttl = dns_ttl
        self.dns_forward = dns_forward
        self.addresses = addresses
        self.addresses6 = addresses6
        self.ra_period = ra_period
        if dhcp_nameservers is None:
            self.dhcp_nameserver = []
        else:
            self.dhcp_nameservers = dhcp_nameservers

        if ipv6_nameservers is None:
            self.ipv6_nameservers = []
        else:
            self.ipv6_nameservers = ipv6_nameservers

        self.ipv6_enabled = False

        self.clients = {}
        self.rev_clients = {}
        self.subnets = {}
        self.ifaces = {}
        self.rev_ifaces = {}
        self.v6nets = {}
        self.address_lists = {}
        self.nfq = {}
        self.l2socket = socket.socket(socket.AF_PACKET,
                                      socket.SOCK_RAW, ETH_P_ALL)
        self.l2socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)

        # Inotify setup
        self.wm = pyinotify.WatchManager()
        mask = pyinotify.EventsCodes.ALL_FLAGS["IN_DELETE"]
        mask |= pyinotify.EventsCodes.ALL_FLAGS["IN_CLOSE_WRITE"]
        mask |= pyinotify.EventsCodes.ALL_FLAGS["IN_Q_OVERFLOW"]
        inotify_handler = ClientFileHandler(self)
        self.notifier = pyinotify.Notifier(self.wm, inotify_handler)
        self.wm.add_watch(self.data_path, mask, rec=True)

        # NFQUEUE setup
        if dhcp_queue_num is not None:
            self._setup_nfqueue(dhcp_queue_num, AF_INET, self.dhcp_response)

        if rs_queue_num is not None:
            self._setup_nfqueue(rs_queue_num, AF_INET6, self.rs_response)
            self.ipv6_enabled = True

        if ns_queue_num is not None:
            self._setup_nfqueue(ns_queue_num, AF_INET6, self.ns_response)
            self.ipv6_enabled = True

        if dns_queue_num is not None:
            self._setup_nfqueue(dns_queue_num, AF_INET, self.dns_response)

        if dns6_queue_num is not None:
            self._setup_nfqueue(dns6_queue_num, AF_INET6, self.dns6_response)

    def _cleanup(self):
        """ Free all resources for a graceful exit

        """
        logging.info("Cleaning up")

        logging.debug("Closing netfilter queues")
        for q in self.nfq.values():
            q.close()

        logging.debug("Closing socket")
        self.l2socket.close()

        logging.debug("Stopping inotify watches")
        self.notifier.stop()

        logging.info("Cleanup finished")

    def _setup_nfqueue(self, queue_num, family, callback):
        logging.debug("Setting up NFQUEUE for queue %d, AF %s",
                      queue_num, family)
        q = nfqueue.queue()
        q.set_callback(callback)
        q.fast_open(queue_num, family)
        q.set_queue_maxlen(5000)
        # This is mandatory for the queue to operate
        q.set_mode(nfqueue.NFQNL_COPY_PACKET)
        self.nfq[q.get_fd()] = q

    def sendp(self, data, iface):
        """ Send a raw packet using a layer-2 socket

        """
        if isinstance(data, BasePacket):
            data = str(data)

        self.l2socket.bind((iface, ETH_P_ALL))
        count = self.l2socket.send(data)
        ldata = len(data)
        if count != ldata:
            logging.warn("Truncated send on %s (%d/%d bytes sent)",
                         iface, count, ldata)

    def build_config(self):
        self.clients.clear()
        self.subnets.clear()

        for path in glob.glob(os.path.join(self.data_path, "*")):
            self.add_iface(path)

    def get_ifindex(self, iface):
        """ Get the interface index from sysfs

        """
        path = os.path.abspath(os.path.join(SYSFS_NET, iface, "ifindex"))
        if not path.startswith(SYSFS_NET):
            return None

        ifindex = None

        try:
            f = open(path, 'r')
        except EnvironmentError:
            logging.debug("%s is probably down", iface)
            self.remove_iface(iface)
            return ifindex

        try:
            ifindex = f.readline().strip()
            try:
                ifindex = int(ifindex)
            except ValueError, e:
                logging.warn("Failed to get ifindex for %s, cannot parse sysfs"
                             " output '%s'", iface, ifindex)
                self.remove_iface(iface)
        except EnvironmentError, e:
            logging.warn("Error reading %s's ifindex from sysfs: %s",
                         iface, str(e))
            self.remove_iface(iface)
        finally:
            f.close()

        return ifindex


    def get_iface_hw_addr(self, iface):
        """ Get the interface hardware address from sysfs

        """
        path = os.path.abspath(os.path.join(SYSFS_NET, iface, "address"))
        if not path.startswith(SYSFS_NET):
            return None

        addr = None
        try:
            f = open(path, 'r')
        except EnvironmentError:
            logging.debug("%s is probably down, removing", iface)
            self.remove_iface(iface)
            return addr

        try:
            addr = f.readline().strip()
        except EnvironmentError, e:
            logging.warn("Failed to read hw address for %s from sysfs: %s",
                         iface, str(e))
            self.remove_iface(iface)
        finally:
            f.close()

        return addr

    def add_iface(self, path):
        """ Add an interface to monitor

        """
        iface = os.path.basename(path)

        if iface.startswith("address_list"):
            al = parse_address_list_file(path)
            if al is not None:
                self.address_lists[iface] = al
            return

        logging.debug("Updating configuration for %s", iface)
        binding = parse_binding_file(path)
        if binding is None:
            return
        ifindex = self.get_ifindex(iface)

        if ifindex is None:
            logging.warn("Stale configuration for %s found", iface)
        else:
            if binding.is_valid():
                binding.iface = iface
                self.clients[binding.mac] = binding
                self.rev_clients[iface] = binding.mac
                if binding.link is None:
                    self.subnets[iface] = Subnet(binding.subnet,
                                                 binding.gateway)
                    self.v6nets[iface] = Subnet(binding.subnet6,
                                                binding.gateway6)
                else:
                    self.subnets[iface] = parse_routing_table(binding.link)
                    self.v6nets[iface] = parse_routing_table(binding.link, 6)
                logging.debug("Added client %s on %s", binding.mac, iface)
                self.ifaces[ifindex] = iface
                self.rev_ifaces[iface] = ifindex

    def remove_iface(self, iface):
        """ Cleanup clients on a removed interface

        """
        if iface in self.address_lists:
            del self.address_lists[iface]
            return

        if iface in self.subnets:
            del self.subnets[iface]

        if iface in self.v6nets:
            del self.v6nets[iface]

        if iface in self.rev_clients:
            del self.clients[self.rev_clients[iface]]
            del self.rev_clients[iface]

        if iface in self.rev_ifaces:
            del self.ifaces[self.rev_ifaces[iface]]
            del self.rev_ifaces[iface]

        logging.debug("Removed interface %s", iface)

    def dhcp_response(self, i, payload): # pylint: disable=W0613,R0914
        """ Generate a reply to a BOOTP/DHCP request

        """
        # If the packet comes from a bridged interface, use the ifindex
        # of the physical device instead of the ifindex of the bridge interface
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            # We don't know anything about this interface, so accept the packet
            # and return
            logging.debug("Ignoring DHCP request on unknown iface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Decode the response - NFQUEUE relays IP packets
        pkt = IP(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        if not BOOTP in pkt:
            logging.warn("Invalid request on %s, no BOOTP"
                         " payload found", iface)
            return

        if not UDP in pkt:
            logging.warn("Invalid request on %s, no UDP"
                         " payload found", iface)
            return

        # Get the client MAC address
        resp = pkt[BOOTP].copy()
        hlen = resp.hlen
        mac = resp.chaddr[:hlen].encode("hex")
        mac, _ = re.subn(r'([0-9a-fA-F]{2})', r'\1:', mac, hlen-1)

        # Server responses are always BOOTREPLYs
        resp.op = "BOOTREPLY"
        del resp.payload

        try:
            binding = self.clients[mac]
        except KeyError:
            logging.warn("Invalid client %s on %s", mac, iface)
            return

        if iface != binding.iface:
            logging.warn("Received spoofed DHCP request for %s from interface"
                         " %s instead of %s", mac, iface, binding.iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        resp = Ether(dst=mac, src=ifmac)/\
               IP(src=binding.dhcp_server_ip or\
                  self.dhcp_server_ip or\
                  binding.nameservers[0],
                  dst=binding.ip)/\
               UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)/resp
        subnet = self.subnets[iface]

        if not DHCP in pkt:
            logging.warn("Invalid request from %s on %s, no DHCP"
                         " payload found", binding.mac, iface)
            return

        dhcp_options = []
        requested_addr = binding.ip
        for opt in pkt[DHCP].options:
            if type(opt) is tuple and opt[0] == "message-type":
                req_type = opt[1]
            if type(opt) is tuple and opt[0] == "requested_addr":
                requested_addr = opt[1]

        logging.info("%s from %s on %s", DHCP_TYPES.get(req_type, "UNKNOWN"),
                     binding.mac, iface)

        domainname = binding.domain or self.dhcp_domain
        nameservers = binding.nameservers or self.dhcp_nameservers

        if req_type == DHCPREQUEST and requested_addr != binding.ip:
            resp_type = DHCPNAK
            logging.info("Sending DHCPNAK to %s on %s: requested %s"
                         " instead of %s", binding.mac, iface, requested_addr,
                         binding.ip)

        elif req_type in (DHCPDISCOVER, DHCPREQUEST):
            resp_type = DHCP_REQRESP[req_type]
            resp.yiaddr = binding.ip
            dhcp_options += [
                 ("broadcast_address", str(subnet.broadcast)),
                 ("subnet_mask", str(subnet.netmask)),
                 ("renewal_time", self.lease_renewal),
                 ("lease_time", self.lease_lifetime),
            ]
            if binding.hostname:
                dhcp_options += [("hostname", binding.hostname)]
            if domainname:
                dhcp_options += [("domain", domainname)]
            if subnet.gw:
                dhcp_options += [("router", subnet.gw)]
            dhcp_options += [("name_server", x) for x in nameservers]

        elif req_type == DHCPINFORM:
            resp_type = DHCP_REQRESP[req_type]
            if binding.hostname:
                dhcp_options += [("hostname", binding.hostname)]
            if domainname:
                dhcp_options += [("domain", domainname)]
            dhcp_options += [("name_server", x) for x in nameservers]

        elif req_type == DHCPRELEASE:
            # Log and ignore
            logging.info("DHCPRELEASE from %s on %s", binding.mac, iface)
            return

        # Finally, always add the server identifier and end options
        dhcp_options += [
            ("message-type", resp_type),
            ("server_id", binding.dhcp_server_ip or\
                          self.dhcp_server_ip or\
                          binding.nameservers[0]),
            "end"
        ]
        resp /= DHCP(options=dhcp_options)

        logging.info("%s to %s (%s) on %s", DHCP_TYPES[resp_type], mac,
                     binding.ip, iface)
        self.sendp(resp, iface)

    def rs_response(self, i, payload): # pylint: disable=W0613
        """ Generate a reply to an ICMPv6 router solicitation

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            logging.debug("Ignoring router solicitation on"
                          " unknown interface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        subnet = self.v6nets[iface]
        ifll = make_ll64(ifmac)

        resp = Ether(dst=binding.mac, src=ifmac)/\
               IPv6(src=str(ifll))/ICMPv6ND_RA(routerlifetime=14400)/\
               ICMPv6NDOptPrefixInfo(prefix=str(subnet.prefix),
                                     prefixlen=subnet.prefixlen)

        nameservers = binding.nameservers6 or self.ipv6_nameservers

        if nameservers:
            resp /= ICMPv6NDOptRDNSS(dns=nameservers,
                                     lifetime=self.ra_period * 3)

        logging.info("RA on %s for %s", iface, subnet.net)
        self.sendp(resp, iface)

    def ns_response(self, i, payload): # pylint: disable=W0613
        """ Generate a reply to an ICMPv6 neighbor solicitation

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            logging.debug("Ignoring neighbour solicitation on"
                          " unknown interface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        subnet = self.v6nets[iface]
        ifll = make_ll64(ifmac)

        ns = IPv6(payload.get_data())

        if not ICMPv6ND_NS in ns:
            logging.warn("Invalid request on %s, no ICMPv6ND_NS"
                         " payload found", iface)
            return

        tgt = ns[ICMPv6ND_NS].tgt

        if subnet.net.overlaps(tgt) and (str(tgt) != str(ifll)):
            logging.debug("Received NS for a non-routable IP (%s)", tgt)
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        resp = Ether(src=ifmac, dst=binding.mac)/\
               IPv6(src=str(ifll), dst=ns.src)/\
               ICMPv6ND_NA(R=1, O=0, S=1, tgt=tgt)/\
               ICMPv6NDOptDstLLAddr(lladdr=ifmac)

        logging.info("NA on %s for %s", iface, tgt)
        self.sendp(resp, iface)
        return

    def _dns_response(self, i, payload, ipv6): # pylint: disable=W0613,R0914
        """ Generate a reply to a DNS query

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            # We don't know anything about this interface, so accept the packet
            # and return
            logging.debug("Ignoring DNS request on unknown iface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Decode the response - NFQUEUE relays IP packets
        pkt = (IPv6 if ipv6 else IP)(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        if not UDP in pkt:
            logging.warn("Invalid request from %s on %s, no UDP"
                         " payload found", binding.mac, iface)
            return

        if not DNS in pkt:
            logging.warn("Invalid request from %s on %s, no DNS"
                         " payload found", binding.mac, iface)
            return

        if not DNSQR in pkt:
            logging.warn("Invalid request from %s on %s, no DNSQR"
                         " payload found", binding.mac, iface)
            return

        resp = Ether(dst=binding.mac, src=ifmac)
        
        if ipv6:
            resp /= IPv6(src=binding.dns_server_ip6 or\
                             self.dns_server_ip6 or\
                             binding.nameservers6[0],
                         dst=str(make_ll64(binding.mac)))
        else:
            resp /= IP(src=binding.dns_server_ip or\
                           self.dns_server_ip or\
                           binding.nameservers[0],
                       dst=binding.ip)

        resp /= UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)

        qname = pkt[DNSQR].qname
        qtype = pkt[DNSQR].qtype
        qtypename = scapy_dns.dnsqtypes[qtype]
        addr = None

        if (qtypename != "A") and (qtypename != "AAAA"):
            logging.warn("Unsupported request for %s type %s from %s on %s",
                         qname, qtypename, binding.mac, iface)
        else:
            q6 = qtypename == "AAAA"
            # first look in binding
            addr = (binding.addresses6 if q6 else binding.addresses).get(qname)
            if addr is None:
                # look in all address lists specified by the binding
                for alname in binding.address_lists:
                    al = self.address_lists.get("address_list_" + alname)
                    if al is not None:
                        addr = (al.addresses6 if q6 else al.addresses).get(qname)
                        if addr is not None:
                            break
            if addr is None:
                # look in global config
                addr = (self.addresses6 if q6 else self.addresses).get(qname)
            if addr is None and\
               self.dns_forward and\
               (binding.dns_forward is not False):
                logging.debug("Performing DNS lookup for %s type %s from %s on %s", qname, qtypename, binding.mac, iface)
                try:
                    info = socket.getaddrinfo(qname, None,
                        socket.AF_INET if qtypename == "A" else socket.AF_INET6)
                    if info:
                        addr = info[0][4][0]
                except socket.error, e:
                    logging.warn("DNS lookup for %s type %s failed from %s on %s: %s", qname, qtypename, binding.mac, iface, str(e))
        if addr:
            resp /= DNS(id=pkt[DNS].id, qr=1, aa=1,
                        an=DNSRR(rrname=qname,
                                 rdata=addr,
                                 type=qtype,
                                 ttl=binding.dns_ttl or self.dns_ttl))
        else:
            resp /= DNS(id=pkt[DNS].id, qr=1, aa=1, rcode='name-error')

        logging.info("DNS %s->%s to %s (%s) on %s",
                     qname, addr, binding.mac, resp[IPv6 if ipv6 else IP].dst, iface)

        self.sendp(resp, iface)

    def dns_response(self, i, payload): # pylint: disable=W0613,R0914
        return self._dns_response(i, payload, False)

    def dns6_response(self, i, payload): # pylint: disable=W0613,R0914
        return self._dns_response(i, payload, True) 

    def send_periodic_ra(self):
        # Use a separate thread as this may take a _long_ time with
        # many interfaces and we want to be responsive in the mean time
        threading.Thread(target=self._send_periodic_ra).start()

    def _send_periodic_ra(self):
        logging.debug("Sending out periodic RAs")
        start = time.time()
        i = 0
        for client in self.clients.values():
            iface = client.iface
            ifmac = self.get_iface_hw_addr(iface)
            if not ifmac:
                continue

            subnet = self.v6nets[iface]
            if subnet.net is None:
                logging.debug("Skipping periodic RA on interface %s,"
                              " as it is not IPv6-connected", iface)
                continue

            ifll = make_ll64(ifmac)
            resp = Ether(src=ifmac)/\
                   IPv6(src=str(ifll))/ICMPv6ND_RA(routerlifetime=14400)/\
                   ICMPv6NDOptPrefixInfo(prefix=str(subnet.prefix),
                                         prefixlen=subnet.prefixlen)

            nameservers = client.nameservers6 or self.ipv6_nameservers

            if nameservers:
                resp /= ICMPv6NDOptRDNSS(dns=nameservers,
                                         lifetime=self.ra_period * 3)
            try:
                self.sendp(resp, iface)
            except socket.error, e:
                logging.warn("Periodic RA on %s failed: %s", iface, str(e))
            except Exception, e:
                logging.warn("Unkown error during periodic RA on %s: %s",
                             iface, str(e))
            i += 1
        logging.debug("Sent %d RAs in %.2f seconds", i, time.time() - start)

    def serve(self):
        """ Safely perform the main loop, freeing all resources upon exit

        """
        try:
            self._serve()
        finally:
            self._cleanup()

    def _serve(self):
        """ Loop forever, serving DHCP requests

        """
        self.build_config()

        # Yes, we are accessing _fd directly, but it's the only way to have a
        # single select() loop ;-)
        iwfd = self.notifier._fd # pylint: disable=W0212

        start = time.time()
        if self.ipv6_enabled:
            timeout = self.ra_period
            self.send_periodic_ra()
        else:
            timeout = None

        while True:
            rlist, _, xlist = select(self.nfq.keys() + [iwfd], [], [], timeout)
            if xlist:
                logging.warn("Warning: Exception on %s",
                             ", ".join([ str(fd) for fd in xlist]))

            if rlist:
                if iwfd in rlist:
                # First check if there are any inotify (= configuration change)
                # events
                    self.notifier.read_events()
                    self.notifier.process_events()
                    rlist.remove(iwfd)

                for fd in rlist:
                    try:
                        self.nfq[fd].process_pending()
                    except RuntimeError, e:
                        logging.warn("Error processing fd %d: %s", fd, str(e))
                    except Exception, e:
                        logging.warn("Unknown error processing fd %d: %s",
                                     fd, str(e))

            if self.ipv6_enabled:
                # Calculate the new timeout
                timeout = self.ra_period - (time.time() - start)

                if timeout <= 0:
                    start = time.time()
                    self.send_periodic_ra()
                    timeout = self.ra_period - (time.time() - start)


if __name__ == "__main__":
    import capng
    import optparse
    from cStringIO import StringIO
    from pwd import getpwnam, getpwuid
    from configobj import ConfigObj, ConfigObjError, flatten_errors

    import validate

    validator = validate.Validator()

    def is_ip_list(value, family=4):
        try:
            family = int(family)
        except ValueError:
            raise validate.VdtParamError(family)
        if isinstance(value, (str, unicode)):
            value = [value]
        if not isinstance(value, list):
            raise validate.VdtTypeError(value)

        for entry in value:
            try:
                ip = IPy.IP(entry)
            except ValueError:
                raise validate.VdtValueError(entry)

            if ip.version() != family:
                raise validate.VdtValueError(entry)
        return value

    def is_ip6_addr(value):
        try:
            ip = IPy.IP(value)
        except ValueError:
            raise validate.VdtValueError(value)

        if ip.version() != 6:
            raise validate.VdtValueError(value)

        return value

    validator.functions["ip_addr_list"] = is_ip_list
    validator.functions['ip6_addr'] = is_ip6_addr
    config_spec = StringIO(CONFIG_SPEC)


    parser = optparse.OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
                      help="The location of the data files", metavar="FILE",
                      default=DEFAULT_CONFIG)
    parser.add_option("-d", "--debug", action="store_true", dest="debug",
                      help="Turn on debugging messages")
    parser.add_option("-f", "--foreground", action="store_false",
                      dest="daemonize", default=True,
                      help="Do not daemonize, stay in the foreground")


    opts, args = parser.parse_args()

    try:
        config = ConfigObj(opts.config_file, configspec=config_spec)
    except ConfigObjError, err:
        sys.stderr.write("Failed to parse config file %s: %s" %
                         (opts.config_file, str(err)))
        sys.exit(1)

    results = config.validate(validator)
    if results != True:
        logging.fatal("Configuration file validation failed! See errors below:")
        for (section_list, key, unused) in flatten_errors(config, results):
            if key is not None:
                logging.fatal(" '%s' in section '%s' failed validation",
                              key, ", ".join(section_list))
            else:
                logging.fatal(" Section '%s' is missing",
                              ", ".join(section_list))
        sys.exit(1)

    logger = logging.getLogger()
    if opts.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    if opts.daemonize:
        logfile = os.path.join(config["general"]["logdir"], LOG_FILENAME)
        handler = logging.handlers.RotatingFileHandler(logfile,
                                                       maxBytes=2097152)
    else:
        handler = logging.StreamHandler()

    handler.setFormatter(logging.Formatter(LOG_FORMAT))
    logger.addHandler(handler)

    if opts.daemonize:
        pidfile = daemon.pidlockfile.TimeoutPIDLockFile(
            config["general"]["pidfile"], 10)

        d = daemon.DaemonContext(pidfile=pidfile,
                                 stdout=handler.stream,
                                 stderr=handler.stream,
                                 files_preserve=[handler.stream])
        d.umask = 0022
        d.open()

    logging.info("Starting up")

    proxy_opts = {}
    if config["dhcp"].as_bool("enable_dhcp"):
        proxy_opts.update({
            "dhcp_queue_num": config["dhcp"].as_int("dhcp_queue"),
            "dhcp_lease_lifetime": config["dhcp"].as_int("lease_lifetime"),
            "dhcp_lease_renewal": config["dhcp"].as_int("lease_renewal"),
            "dhcp_server_ip": config["dhcp"]["server_ip"],
            "dhcp_nameservers": config["dhcp"]["nameservers"],
            "dhcp_domain": config["dhcp"]["domain"],
        })

    if config["ipv6"].as_bool("enable_ipv6"):
        proxy_opts.update({
            "rs_queue_num": config["ipv6"].as_int("rs_queue"),
            "ns_queue_num": config["ipv6"].as_int("ns_queue"),
            "ra_period": config["ipv6"].as_int("ra_period"),
            "ipv6_nameservers": config["ipv6"]["nameservers"],
        })

    if config["dns"].as_bool("enable_dns"):
        proxy_opts.update({
            "dns_queue_num": config["dns"].as_int("dns_queue"),
            "dns6_queue_num": config["dns"].as_int("dns6_queue"),
            "dns_server_ip": config["dns"]["server_ip"],
            "dns_server_ip6": config["dns"]["server_ip6"],
            "dns_ttl": config["dns"]["ttl"],
            "dns_forward": config["dns"]["forward"],
            "addresses": config["addresses"],
            "addresses6": config["addresses6"]
        })

    # pylint: disable=W0142
    proxy = VMNetProxy(data_path=config["general"]["datapath"], **proxy_opts)

    # Drop all capabilities except CAP_NET_RAW and change uid
    try:
        uid = getpwuid(config["general"].as_int("user"))
    except ValueError:
        uid = getpwnam(config["general"]["user"])

    logging.debug("Setting capabilities and changing uid")
    logging.debug("User: %s, uid: %d, gid: %d",
                  config["general"]["user"], uid.pw_uid, uid.pw_gid)

    # Keep only the capabilities we need
    # CAP_NET_ADMIN: we need to send nfqueue packet verdicts to a netlinkgroup
    capng.capng_clear(capng.CAPNG_SELECT_BOTH)
    capng.capng_update(capng.CAPNG_ADD,
                       capng.CAPNG_EFFECTIVE|capng.CAPNG_PERMITTED,
                       capng.CAP_NET_ADMIN)
    capng.capng_change_id(uid.pw_uid, uid.pw_gid,
                          capng.CAPNG_DROP_SUPP_GRP|capng.CAPNG_CLEAR_BOUNDING)

    logging.info("Ready to serve requests")
    try:
        proxy.serve()
    except Exception:
        if opts.daemonize:
            exc = "".join(traceback.format_exception(*sys.exc_info()))
            logging.critical(exc)
        raise


# vim: set ts=4 sts=4 sw=4 et :
