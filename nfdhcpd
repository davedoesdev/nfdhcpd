#!/usr/bin/env python
#

# nfdcpd: A promiscuous, NFQUEUE-based DHCP server for virtual machine hosting
# Copyright (c) 2010 GRNET SA
# Parts copyright (c) 2015 David Halls <dahalls@gmail.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

import os
import signal
import errno
import re
import sys
import glob
import time
import logging
import logging.handlers
import threading
import traceback
import subprocess
from binascii import hexlify
from functools import partial
from StringIO import StringIO

import daemon
import daemon.runner
import daemon.pidlockfile
import nfqueue
import pyinotify
from lockfile import LockTimeout
from dns import resolver
from dns.exception import DNSException

import IPy
import socket
import select
from socket import AF_INET, AF_INET6

from scapy.data import ETH_P_ALL
from scapy.packet import BasePacket, Raw, Packet
from scapy.layers.l2 import Ether
from scapy.layers.inet import IP, UDP
from scapy.layers.inet6 import IPv6, ICMPv6ND_RA, ICMPv6ND_NA, \
                               ICMPv6ND_NS, \
                               ICMPv6NDOptDstLLAddr, \
                               ICMPv6NDOptPrefixInfo, \
                               ICMPv6NDOptRDNSS, \
                               ICMPv6NDOptMTU, \
                               get_cls, \
                               icmp6ndoptscls
from scapy.layers.dhcp import BOOTP, DHCP
from scapy.layers.dhcp6 import DHCP6_Reply, DHCP6OptDNSServers, \
                               DHCP6OptServerId, DHCP6OptClientId, \
                               DUID_LLT, DHCP6_InfoRequest, \
                               DHCP6OptDNSDomains, DHCP6OptUnknown
from scapy.layers.dns import DNS, DNSQR, DNSRR
import scapy.layers.dns as scapy_dns
from scapy.fields import ShortField, ByteField, FieldLenField, IntField, StrLenField
import scapy.layers.dhcp as scapy_dhcp

scapy_dhcp.DHCPOptions[26] = ShortField("interface_mtu", 1500)
scapy_dhcp.DHCPRevOptions["interface_mtu"] = (26, scapy_dhcp.DHCPOptions[26])
scapy_dhcp.DHCPOptions[119] = "domain_search"
scapy_dhcp.DHCPRevOptions["domain_search"] = (119, None)

class _ICMPv6NDGuessPayload:
    name = "Dummy ND class that implements guess_payload_class()"
    def guess_payload_class(self,p):
        if len(p) > 1:
            return get_cls(icmp6ndoptscls.get(ord(p[0]),"Raw"), "Raw")

class ICMPv6NDOptDNSSL(_ICMPv6NDGuessPayload, Packet): # RFC 6106
    name = "ICMPv6 Neighbor Discovery Option - DNS Search List Option"
    fields_desc = [ ByteField("type", 31),
                    FieldLenField("len",
                                  None,
                                  length_of="search",
                                  fmt="B",
                                  adjust=lambda pkt,x:x/8+1),
                    ShortField("res", None),
                    IntField("lifetime", 0xffffffff),
                    StrLenField("search",
                                default="",
                                length_from=lambda pkt: (pkt.len-1)*8 ) ]

DEFAULT_CONFIG = "/etc/nfdhcpd/nfdhcpd.conf"
DEFAULT_PATH = "/var/run/ganeti-dhcpd"
DEFAULT_USER = "nobody"
DEFAULT_LEASE_LIFETIME = 604800 # 1 week
DEFAULT_LEASE_RENEWAL = 600  # 10 min
DEFAULT_RA_PERIOD = 300 # seconds
DEFAULT_DNS_TTL = 10 # seconds
DEFAULT_DNS_FORWARD = False
DEFAULT_NOTIFY_PERIOD = 60 # seconds

LOG_FILENAME = "nfdhcpd.log"

SYSFS_NET = "/sys/class/net"

LOG_FORMAT = "%(asctime)-15s %(levelname)-8s %(message)s"

# Configuration file specification (see configobj documentation)
CONFIG_SPEC = """
[general]
pidfile = string()
datapath = string()
logdir = string()
user = string()

[dhcp]
enable_dhcp = boolean(default=True)
lease_lifetime = integer(min=0, max=4294967295)
lease_renewal = integer(min=0, max=4294967295)
server_ip = ip_addr(default=None)
dhcp_queue = integer(min=-1, max=65535, default=-1)
dhcp6_queue = integer(min=-1, max=65535, default=-1)
dhcp6_hostname_optcode = integer(min=-1, max=65535, default=-1)
dhcp6_domainname_optcode = integer(min=-1, max=65535, default=-1)
nameservers = ip_addr_list(family=4, default=None)
domain = string(default=None)
domain_search = string_list(default=None)

[ipv6]
enable_ipv6 = boolean(default=True)
ra_period = integer(min=1, max=4294967295)
rs_queue = integer(min=-1, max=65535, default=-1)
ns_queue = integer(min=-1, max=65535, default=-1)
nameservers = ip_addr_list(family=6, default=None)

[dns]
enable_dns = boolean(default=False)
dns_queue = integer(min=-1, max=65535, default=-1)
dns6_queue = integer(min=-1, max=65535, default=-1)
server_ip = ip_addr(default=None)
server_ip6 = ip6_addr(default=None)
ttl = integer(min=0, max=2147483647, default=10)
forward = boolean(default=False)
no_forward = string_list(default=None)
nameservers = ip_addr_list(family=4, default=None)
nameservers6 = ip_addr_list(family=6, default=None)

[notify]
enable_notify = boolean(default=False)
notify_period = integer(min=1, max=4294967295)
notify_queue = integer(min=-1, max=65535, default=-1)
notify6_queue = integer(min=-1, max=65535, default=-1)

[addresses]

[addresses6]

[txts]
"""


DHCPDISCOVER = 1
DHCPOFFER = 2
DHCPREQUEST = 3
DHCPDECLINE = 4
DHCPACK = 5
DHCPNAK = 6
DHCPRELEASE = 7
DHCPINFORM = 8

DHCP_TYPES = {
    DHCPDISCOVER: "DHCPDISCOVER",
    DHCPOFFER: "DHCPOFFER",
    DHCPREQUEST: "DHCPREQUEST",
    DHCPDECLINE: "DHCPDECLINE",
    DHCPACK: "DHCPACK",
    DHCPNAK: "DHCPNAK",
    DHCPRELEASE: "DHCPRELEASE",
    DHCPINFORM: "DHCPINFORM",
}

DHCP_REQRESP = {
    DHCPDISCOVER: DHCPOFFER,
    DHCPREQUEST: DHCPACK,
    DHCPINFORM: DHCPACK,
}


def parse_routing_table(table="main", family=4):
    """ Parse the given routing table to get connected route, gateway and
    default device.

    """
    ipro = subprocess.Popen(["ip", "-%d" % family, "ro", "ls",
                             "table", table], stdout=subprocess.PIPE)
    routes = ipro.stdout.readlines()

    def_gw = None
    def_dev = None
    def_net = None

    for route in routes:
        match = re.match(r'^default.*via ([^\s]+).*dev ([^\s]+)', route)
        if match:
            def_gw, def_dev = match.groups()
            break

    for route in routes:
        # Find the least-specific connected route
        m = re.match("^([^\\s]+) dev %s" % def_dev, route)
        if not m:
            continue

        if family == 6 and m.group(1).startswith("fe80:"):
            # Skip link-local declarations in "main" table
            continue

        def_net = m.group(1)

        try:
            def_net = IPy.IP(def_net)
        except ValueError, e:
            logging.warn("Unable to parse default route entry %s: %s",
                         def_net, str(e))

    return Subnet(net=def_net, gw=def_gw)


def parse_binding_file(path):
    """ Read a client configuration binding file

    """
    try:
        iffile = open(path, 'r')
    except EnvironmentError, e:
        logging.warn("Unable to open binding file %s: %s", path, str(e))
        return None

    try:
        mtu = None
        mac = None
        ip = None
        ip6 = None
        link = None
        hostname = None
        subnet = None
        gateway = None
        subnet6 = None
        gateway6 = None
        gateway6_mac = None
        dhcp_server_ip = None
        dhcp6_hostname_optcode = None
        dhcp6_domainname_optcode = None
        dns_server_ip = None
        dns_server_ip6 = None
        nameservers = []
        nameservers6 = []
        domain = None
        domain_search = []
        dns_ttl = None
        dns_forward = None
        addresses = {}
        addresses6 = {}
        txts = {}
        address_lists = {}
        no_forward = []
        dns_nameservers = []
        dns_nameservers6 = []
        notify_port = None
        notify_ip = None
        notify_ip6 = None
        bridge = None

        for line in iffile:
            if line.startswith("#"):
                continue
            elif line.startswith("MTU="):
                mtu = int(line.split("=")[1].strip())
            elif line.startswith("IP="):
                ip = line.split("=")[1].strip()
            elif line.startswith("IP6="):
                ip6 = line.split("=")[1].strip()
            elif line.startswith("MAC="):
                mac = line.split("=")[1].strip()
            elif line.startswith("LINK="):
                link = line.split("=")[1].strip()
            elif line.startswith("HOSTNAME="):
                hostname = line.split("=")[1].strip()
            elif line.startswith("SUBNET="):
                subnet = line.split("=")[1].strip()
            elif line.startswith("GATEWAY="):
                gateway = line.split("=")[1].strip()
            elif line.startswith("SUBNET6="):
                subnet6 = line.split("=")[1].strip()
            elif line.startswith("GATEWAY6="):
                gateway6 = line.split("=")[1].strip()
            elif line.startswith("GATEWAY6_MAC="):
                gateway6_mac = line.split("=")[1].strip()
            elif line.startswith("DHCP_SERVER_IP="):
                dhcp_server_ip = line.split("=")[1].strip()
            elif line.startswith("DNS_SERVER_IP="):
                dns_server_ip = line.split("=")[1].strip()
            elif line.startswith("DNS_SERVER_IP6="):
                dns_server_ip6 = line.split("=")[1].strip()
            elif line.startswith("NAMESERVERS="):
                nameservers += [ns.strip() for ns in
                                line.split("=")[1].split(",")]
            elif line.startswith("NAMESERVERS6="):
                nameservers6 += [ns.strip() for ns in
                                 line.split("=")[1].split(",")]
            elif line.startswith("DOMAIN="):
                domain = line.split("=")[1].strip()
            elif line.startswith("DOMAIN_SEARCH="):
                domain_search = [d.strip() for d in
                                 line.split("=")[1].split(",")]
            elif line.startswith("DNS_TTL="):
                dns_ttl = int(line.split("=")[1].strip())
            elif line.startswith("DNS_FORWARD="):
                dns_forward = line.split("=")[1].strip().lower()
                dns_forward = (dns_forward == "true") or (dns_forward == "yes")
            elif line.startswith("ADDRESS:"):
                entry = line[8:].split("=")
                addresses[entry[0].strip()] = entry[1].strip()
            elif line.startswith("ADDRESS6:"):
                entry = line[9:].split("=")
                addresses6[entry[0].strip()] = entry[1].strip()
            elif line.startswith('TXT:'):
                entry = line[4:].split("=")
                txts[entry[0].strip()] = entry[1].strip()
            elif line.startswith("ADDRESS_LISTS="):
                for al in line.split("=")[1].split(","):
                    address_lists[al.strip()] = True
            elif line.startswith("NO_FORWARD="):
                no_forward += [ns.strip() for ns in
                               line.split("=")[1].split(",")]
            elif line.startswith("DNS_NAMESERVERS="):
                dns_nameservers += [ns.strip() for ns in
                                    line.split("=")[1].split(",")]
            elif line.startswith("DNS_NAMESERVERS6="):
                dns_nameservers6 += [ns.strip() for ns in
                                     line.split("=")[1].split(",")]
            elif line.startswith("NOTIFY_PORT="):
                notify_port = int(line.split("=")[1].strip())
            elif line.startswith("NOTIFY_IP="):
                notify_ip = line.split("=")[1].strip()
            elif line.startswith("NOTIFY_IP6="):
                notify_ip6 = line.split("=")[1].strip()
            elif line.startswith("BRIDGE="):
                bridge = line.split("=")[1].strip()
            elif line.startswith("DHCP6_HOSTNAME_OPTCODE="):
                dhcp6_hostname_optcode = int(line.split("=")[1].strip())
            elif line.startswith("DHCP6_DOMAINNAME_OPTCODE="):
                dhcp6_domainname_optcode = int(line.split("=")[1].strip())
            else:
                logging.warn("Unknown line in binding file %s: %s", path, line)

        return Client(mtu=mtu, mac=mac, ip=ip, link=link, hostname=hostname,
                      subnet=subnet, gateway=gateway,
                      subnet6=subnet6, gateway6=gateway6, gateway6_mac=gateway6_mac,
                      dhcp_server_ip=dhcp_server_ip, nameservers=nameservers,
                      nameservers6=nameservers6,
                      domain=domain, domain_search=domain_search,
                      dns_server_ip=dns_server_ip,
                      dns_server_ip6=dns_server_ip6,
                      addresses=addresses, addresses6=addresses6, txts=txts,
                      dns_ttl=dns_ttl, dns_forward=dns_forward,
                      address_lists=address_lists,
                      no_forward=no_forward,
                      dns_nameservers=dns_nameservers, dns_nameservers6=dns_nameservers6,
                      notify_port=notify_port, notify_ip=notify_ip,
                      notify_ip6=notify_ip6, ip6=ip6,
                      bridge=bridge,
                      dhcp6_hostname_optcode=dhcp6_hostname_optcode,
                      dhcp6_domainname_optcode=dhcp6_domainname_optcode)
    finally:
        iffile.close()

def parse_address_list_file(path):
    """ Read an address list file

    """
    try:
        alfile = open(path, 'r')
    except EnvironmentError, e:
        logging.warn("Unable to open address list file %s: %s", path, str(e))
        return None

    try:
        addresses = {}
        addresses6 = {}
        txts = {}
        no_forward = []

        for line in alfile:
            if line.startswith("#"):
                continue
            elif line.startswith("ADDRESS:"):
                entry = line[8:].split("=")
                addresses[entry[0].strip()] = entry[1].strip()
            elif line.startswith("ADDRESS6:"):
                entry = line[9:].split("=")
                addresses6[entry[0].strip()] = entry[1].strip()
            elif line.startswith('TXT:'):
                entry = line[4:].split("=")
                txts[entry[0].strip()] = entry[1].strip()
            elif line.startswith("NO_FORWARD="):
                no_forward += [ns.strip() for ns in
                               line.split("=")[1].split(",")]
            else:
                logging.warn("Unknown line in address list file %s: %s",
                             path, line)

        return AddressList(addresses=addresses, addresses6=addresses6,
                           txts=txts, no_forward=no_forward)

    finally:
        alfile.close()

class ClientFileHandler(pyinotify.ProcessEvent):
    def __init__(self, server):
        pyinotify.ProcessEvent.__init__(self)
        self.server = server

    def process_IN_DELETE(self, event): # pylint: disable=C0103
        """ Delete file handler

        Currently this removes an interface from the watch list

        """
        self.server.remove_iface(event.name)

    def process_IN_CLOSE_WRITE(self, event): # pylint: disable=C0103
        """ Add file handler

        Currently this adds an interface to the watch list

        """
        self.server.add_iface(os.path.join(event.path, event.name))

    def process_IN_Q_OVERFLOW(self, event): # pylint: disable=C0103
        """ Event overflow handler

        Currently this reads all interface configs

        """
        for path in glob.glob(os.path.join(self.server.data_path, "*")):
            self.server.add_iface(path)


class Client(object):
    def __init__(self, mtu=None, mac=None, ip=None, link=None, hostname=None,
                 subnet=None, gateway=None, subnet6=None, gateway6=None, gateway6_mac=None,
                 dhcp_server_ip=None, nameservers=None, nameservers6=None,
                 domain=None, domain_search=None,
                 dns_server_ip=None, dns_server_ip6=None,
                 dns_ttl=None, dns_forward=None,
                 addresses=None, addresses6=None, txts=None,
                 address_lists=None, no_forward=None,
                 dns_nameservers=None, dns_nameservers6=None,
                 notify_port=None, notify_ip=None, notify_ip6=None,
                 ip6=None, bridge=None,
                 dhcp6_hostname_optcode=None, dhcp6_domainname_optcode=None):
        self.mtu = mtu
        self.mac = mac
        self.ip = ip
        self.hostname = hostname
        self.link = link
        self.subnet = subnet
        self.gateway = gateway
        self.subnet6 = subnet6
        self.gateway6 = gateway6
        self.gateway6_mac = gateway6_mac
        self.dhcp_server_ip = dhcp_server_ip
        self.dns_server_ip = dns_server_ip
        self.dns_server_ip6 = dns_server_ip6
        self.dns_ttl = dns_ttl
        self.dns_forward = dns_forward
        self.nameservers = nameservers
        self.nameservers6 = nameservers6
        self.domain = domain
        self.domain_search = domain_search
        self.addresses = {} if addresses is None else addresses
        self.addresses6 = {} if addresses6 is None else addresses6
        self.txts = {} if txts is None else txts
        self.address_lists = {} if address_lists is None else address_lists
        self.no_forward = no_forward
        self.dns_nameservers = dns_nameservers
        self.dns_nameservers6 = dns_nameservers6
        self.notify_port = notify_port
        self.notify_ip = notify_ip
        self.notify_ip6 = notify_ip6
        self.ip6 = ip6
        self.iface = None
        self.seq_in = ""
        self.seq_out = ""
        self.bridge = bridge
        self.dhcp6_hostname_optcode = dhcp6_hostname_optcode
        self.dhcp6_domainname_optcode = dhcp6_domainname_optcode

    def is_valid(self):
        return self.mac is not None

class AddressList(object):
    def __init__(self, addresses=None, addresses6=None, txts=None,
                 no_forward=None):
        self.addresses = {} if addresses is None else addresses
        self.addresses6 = {} if addresses6 is None else addresses6
        self.txts = {} if txts is None else txts
        self.no_forward = [] if no_forward is None else no_forward

def make_eui64(net, mac):
    """ Compute an EUI-64 address from an EUI-48 (MAC) address

    """
    comp = mac.split(":")
    prefix = IPy.IP(net).net().strFullsize().split(":")[:4]
    eui64 = comp[:3] + ["ff", "fe"] + comp[3:]
    eui64[0] = "%02x" % (int(eui64[0], 16) ^ 0x02)
    for l in range(0, len(eui64), 2):
        prefix += ["".join(eui64[l:l+2])]
    return IPy.IP(":".join(prefix))

def make_ll64(mac):
    """ Compute an IPv6 Link-local address from an EUI-48 (MAC) address

    """
    return make_eui64("fe80::", mac)

def format_domain_search(domain):
    return ''.join([chr(len(part)) + part for part in domain.split('.')]) + '\0'

class Subnet(object):
    def __init__(self, net=None, gw=None):
        if isinstance(net, str):
            try:
                self.net = IPy.IP(net)
            except ValueError, e:
                logging.warn("Error parsing subnet %s: %s", net, str(e))
                self.net = None
        else:
            self.net = net
        self.gw = gw

    @property
    def netmask(self):
        """ Return the netmask in textual representation

        """
        return str(self.net.netmask())

    @property
    def broadcast(self):
        """ Return the broadcast address in textual representation

        """
        return str(self.net.broadcast())

    @property
    def prefix(self):
        """ Return the network as an IPy.IP

        """
        return self.net.net()

    @property
    def prefixlen(self):
        """ Return the prefix length as an integer

        """
        return self.net.prefixlen()

def can_forward(no_forward, qname):
    if not no_forward:
        return True
    for x in no_forward:
        if qname.endswith(x):
            return False
    return True

class VMNetProxy(object): # pylint: disable=R0902
    def __init__(self, data_path, dhcp_queue_num=-1, # pylint: disable=R0913
                 rs_queue_num=-1, ns_queue_num=-1,
                 dns_queue_num=-1, dns6_queue_num=-1,
                 dhcp6_queue_num=-1,
                 dhcp6_hostname_optcode=-1,
                 dhcp6_domainname_optcode=-1,
                 dhcp_lease_lifetime=DEFAULT_LEASE_LIFETIME,
                 dhcp_lease_renewal=DEFAULT_LEASE_RENEWAL,
                 dhcp_domain=None,
                 dhcp_domain_search=None,
                 dhcp_server_ip=None, dhcp_nameservers=None,
                 ra_period=DEFAULT_RA_PERIOD, ipv6_nameservers=None,
                 dns_server_ip=None,
                 dns_server_ip6=None,
                 dns_ttl=DEFAULT_DNS_TTL,
                 dns_forward=DEFAULT_DNS_FORWARD,
                 addresses=None, addresses6=None, txts=None, no_forward=None,
                 dns_nameservers=None, dns_nameservers6=None,
                 notify_queue_num=-1,
                 notify6_queue_num=-1,
                 notify_period=DEFAULT_NOTIFY_PERIOD):

        self.data_path = data_path
        self.dhcp_lease_lifetime = dhcp_lease_lifetime
        self.dhcp_lease_renewal = dhcp_lease_renewal
        self.dhcp6_hostname_optcode = dhcp6_hostname_optcode
        self.dhcp6_domainname_optcode = dhcp6_domainname_optcode
        self.dhcp_domain = dhcp_domain
        self.dhcp_domain_search = dhcp_domain_search
        self.dhcp_server_ip = dhcp_server_ip
        self.dns_server_ip = dns_server_ip
        self.dns_server_ip6 = dns_server_ip6
        self.dns_ttl = dns_ttl
        self.dns_forward = dns_forward
        self.addresses = {} if addresses is None else addresses
        self.addresses6 = {} if addresses6 is None else addresses6
        self.txts = {} if txts is None else txts
        self.no_forward = no_forward
        self.dns_nameservers = dns_nameservers
        self.dns_nameservers6 = dns_nameservers6
        self.ra_period = ra_period
        self.notify_period = notify_period

        if dhcp_nameservers is None:
            self.dhcp_nameservers = []
        else:
            self.dhcp_nameservers = dhcp_nameservers

        if dhcp_domain_search is None:
            self.dhcp_domain_search = []
        else:
            self.dhcp_domain_search = dhcp_domain_search

        if ipv6_nameservers is None:
            self.ipv6_nameservers = []
        else:
            self.ipv6_nameservers = ipv6_nameservers

        self.ipv6_enabled = False
        self.notify_enabled = False

        self.clients = {}
        self.rev_clients = {}
        self.subnets = {}
        self.ifaces = {}
        self.rev_ifaces = {}
        self.v6nets = {}
        self.address_lists = {}
        self.nfq = {}

        # Inotify setup
        self.wm = pyinotify.WatchManager()
        mask = pyinotify.EventsCodes.ALL_FLAGS["IN_DELETE"]
        mask |= pyinotify.EventsCodes.ALL_FLAGS["IN_CLOSE_WRITE"]
        mask |= pyinotify.EventsCodes.ALL_FLAGS["IN_Q_OVERFLOW"]
        inotify_handler = ClientFileHandler(self)
        self.notifier = pyinotify.Notifier(self.wm, inotify_handler)
        self.wm.add_watch(self.data_path, mask, rec=True)

        # NFQUEUE setup
        if dhcp_queue_num >= 0:
            self._setup_nfqueue(dhcp_queue_num, AF_INET, self.dhcp_response)

        if dhcp6_queue_num >= 0:
            self._setup_nfqueue(dhcp6_queue_num, AF_INET6, self.dhcp6_response)

        if rs_queue_num >= 0:
            self._setup_nfqueue(rs_queue_num, AF_INET6, self.rs_response)
            self.ipv6_enabled = True

        if ns_queue_num >= 0:
            self._setup_nfqueue(ns_queue_num, AF_INET6, self.ns_response)
            self.ipv6_enabled = True

        if dns_queue_num >= 0:
            self._setup_nfqueue(dns_queue_num, AF_INET, self.dns_response)

        if dns6_queue_num >= 0:
            self._setup_nfqueue(dns6_queue_num, AF_INET6, self.dns6_response)

        if notify_queue_num >= 0:
            self._setup_nfqueue(notify_queue_num, AF_INET, self.notify_handle)
            self.notify_enabled = True

        if notify6_queue_num >= 0:
            self._setup_nfqueue(notify6_queue_num, AF_INET6, self.notify6_handle)
            self.notify_enabled = True

    def _cleanup(self):
        """ Free all resources for a graceful exit

        """
        logging.info("Cleaning up")

        logging.debug("Closing netfilter queues")
        for q in self.nfq.values():
            q.close()

        logging.debug("Stopping inotify watches")
        self.notifier.stop()

        logging.info("Cleanup finished")

    def _setup_nfqueue(self, queue_num, family, callback):
        logging.debug("Setting up NFQUEUE for queue %d, AF %s",
                      queue_num, family)
        q = nfqueue.queue()
        q.set_callback(callback)
        q.fast_open(queue_num, family)
        q.set_queue_maxlen(5000)
        # This is mandatory for the queue to operate
        q.set_mode(nfqueue.NFQNL_COPY_PACKET)
        self.nfq[q.get_fd()] = q
        logging.debug("Successfully set up NFQUEUE %d", queue_num)

    def sendp(self, data, iface):
        """ Send a raw packet using a layer-2 socket

        """
        if isinstance(data, BasePacket):
            data = str(data)

        l2socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, ETH_P_ALL)
        l2socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
        try:
            l2socket.bind((iface, ETH_P_ALL))
            count = l2socket.send(data)
        finally:
            l2socket.close()
        ldata = len(data)
        if count != ldata:
            logging.warn("Truncated send on %s (%d/%d bytes sent)",
                         iface, count, ldata)

    def build_config(self):
        self.clients.clear()
        self.subnets.clear()

        for path in glob.glob(os.path.join(self.data_path, "*")):
            self.add_iface(path)

        self.print_clients()

    def get_ifindex(self, iface):
        """ Get the interface index from sysfs

        """
        logging.debug("Getting ifindex for interface %s from sysfs", iface)

        path = os.path.abspath(os.path.join(SYSFS_NET, iface, "ifindex"))
        if not path.startswith(SYSFS_NET):
            return None

        ifindex = None

        try:
            f = open(path, 'r')
        except EnvironmentError:
            logging.debug("%s is probably down, removing", iface)
            self.remove_iface(iface)
            return ifindex

        try:
            ifindex = f.readline().strip()
            try:
                ifindex = int(ifindex)
            except ValueError, e:
                logging.warn("Failed to get ifindex for %s, cannot parse sysfs"
                             " output '%s'", iface, ifindex)
                self.remove_iface(iface)
        except EnvironmentError, e:
            logging.warn("Error reading %s's ifindex from sysfs: %s",
                         iface, str(e))
            self.remove_iface(iface)
        finally:
            f.close()

        return ifindex


    def get_iface_hw_addr(self, iface):
        """ Get the interface hardware address from sysfs

        """
        logging.debug("Getting mac for iface %s", iface)

        path = os.path.abspath(os.path.join(SYSFS_NET, iface, "address"))
        if not path.startswith(SYSFS_NET):
            return None

        addr = None
        try:
            f = open(path, 'r')
        except EnvironmentError:
            logging.debug("%s is probably down, removing", iface)
            self.remove_iface(iface)
            return addr

        try:
            addr = f.readline().strip()
        except EnvironmentError, e:
            logging.warn("Failed to read hw address for %s from sysfs: %s",
                         iface, str(e))
            self.remove_iface(iface)
        finally:
            f.close()

        return addr

    def notify_bindings(self, bindings, update=True):
        if not self.notify_enabled:
            return

        for b in bindings:
            if not b.notify_port:
                continue

            ifmac = self.get_iface_hw_addr(b.iface)
            if not ifmac:
                continue

            updated = False

            if b.notify_ip:
                if update and not updated:
                    b.seq_out = os.urandom(16)
                    updated = True

                pkt = Ether(src=ifmac, dst=b.mac)/\
                      IP(src=b.notify_ip, dst=b.ip)/\
                      UDP(sport=b.notify_port, dport=b.notify_port)/\
                      b.seq_out

                logging.info("notify to %s (%s) on %s: %s",
                             b.mac, b.ip, b.iface, hexlify(b.seq_out))

                try:
                    self.sendp(pkt, b.iface)
                except socket.error, e:
                    logging.warn("Notify to %s (%s) on %s failed: %s",
                                 b.mac, b.notify_ip, b.iface, str(e))
                except Exception, e:
                    logging.warn("Unkown error during notify to %s (%s) on %s: %s",
                                 b.mac, b.notify_ip, b.iface, str(e))

            if b.notify_ip6:
                if update and not updated:
                    b.seq_out = os.urandom(16)
                    updated = True

                ifll = str(make_ll64(b.mac))
                pkt = Ether(src=ifmac, dst=b.mac)/\
                      IPv6(src=b.notify_ip6, dst=ifll)/\
                      UDP(sport=b.notify_port, dport=b.notify_port)/\
                      b.seq_out

                logging.info("notify to %s (%s) on %s: %s",
                             b.mac, ifll, b.iface, hexlify(b.seq_out))

                try:
                    self.sendp(pkt, b.iface)
                except socket.error, e:
                    logging.warn("Notify to %s (%s) on %s failed: %s",
                                 b.mac, b.notify_ip6, b.iface, str(e))
                except Exception, e:
                    logging.warn("Unkown error during notify to %s (%s) on %s: %s",
                                 b.mac, b.notify_ip6, b.iface, str(e))

    def add_iface(self, path):
        """ Add an interface to monitor

        """
        try:
            iface = os.path.basename(path)

            if iface.startswith("address_list_"):
                iface = iface[13:]
                logging.debug("Updating address list %s", iface)
                al = parse_address_list_file(path)
                if al is not None:
                    self.address_lists[iface] = al
                self.notify_bindings([b for b in self.clients.itervalues()
                                      if iface in b.address_lists])
                return

            logging.debug("Updating configuration for %s", iface)
            binding = parse_binding_file(path)
            if binding is None:
                return
            ifindex = self.get_ifindex(iface)

            if ifindex is None:
                logging.warn("Stale configuration for %s found", iface)
            elif binding.is_valid():
                binding.iface = iface
                self.clients[binding.mac] = binding
                self.rev_clients[iface] = binding.mac
                if binding.link is None:
                    self.subnets[iface] = Subnet(binding.subnet,
                                                 binding.gateway)
                    self.v6nets[iface] = Subnet(binding.subnet6,
                                                binding.gateway6)
                else:
                    self.subnets[iface] = parse_routing_table(binding.link)
                    self.v6nets[iface] = parse_routing_table(binding.link, 6)
                logging.debug("Added client %s on %s", binding.mac, iface)
                self.ifaces[ifindex] = iface
                self.rev_ifaces[iface] = ifindex
                self.notify_bindings([binding])
        except Exception, e:
            logging.warn("Error while adding interface from path %s: %s",
                         path, str(e))
            
    def remove_iface(self, iface):
        """ Cleanup clients on a removed interface

        """
        # dict.pop is atomic for built-in key types

        if self.address_lists.pop(iface, None) is not None:
            return

        self.subnets.pop(iface, None)

        self.v6nets.pop(iface, None)

        mac = self.rev_clients.pop(iface, None)
        if mac is not None:
            self.clients.pop(mac, None)

        ifindex = self.rev_ifaces.pop(iface, None)
        if ifindex is not None:
            self.ifaces.pop(ifindex, None)

        logging.debug("Removed interface %s", iface)

    def dhcp_response(self, i, payload): # pylint: disable=W0613,R0914
        """ Generate a reply to a BOOTP/DHCP request

        """
        # If the packet comes from a bridged interface, use the ifindex
        # of the physical device instead of the ifindex of the bridge interface
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            # We don't know anything about this interface, so accept the packet
            # and return
            logging.debug("Ignoring DHCP request on unknown iface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Decode the response - NFQUEUE relays IP packets
        pkt = IP(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        if not BOOTP in pkt:
            logging.warn("Invalid request on %s, no BOOTP"
                         " payload found", iface)
            return

        if not UDP in pkt:
            logging.warn("Invalid request on %s, no UDP"
                         " payload found", iface)
            return

        # Get the client MAC address
        resp = pkt[BOOTP].copy()
        hlen = resp.hlen
        mac = resp.chaddr[:hlen].encode("hex")
        mac, _ = re.subn(r'([0-9a-fA-F]{2})', r'\1:', mac, hlen-1)

        # Server responses are always BOOTREPLYs
        resp.op = "BOOTREPLY"
        del resp.payload

        try:
            binding = self.clients[mac]
        except KeyError:
            logging.warn("Invalid client %s on %s", mac, iface)
            return

        if iface != binding.iface:
            logging.warn("Received spoofed DHCP request for %s from interface"
                         " %s instead of %s", mac, iface, binding.iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        resp = Ether(dst=mac, src=ifmac)/\
               IP(src=binding.dhcp_server_ip or\
                  self.dhcp_server_ip or\
                  (binding.nameservers and binding.nameservers[0]) or\
                  binding.ip, # not ideal but not configured with any other address
                  dst=binding.ip)/\
               UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)/resp
        subnet = self.subnets[iface]

        if not DHCP in pkt:
            logging.warn("Invalid request from %s on %s, no DHCP"
                         " payload found", binding.mac, iface)
            return

        dhcp_options = []
        requested_addr = binding.ip
        for opt in pkt[DHCP].options:
            if type(opt) is tuple and opt[0] == "message-type":
                req_type = opt[1]
            if type(opt) is tuple and opt[0] == "requested_addr":
                requested_addr = opt[1]

        logging.info("%s from %s on %s", DHCP_TYPES.get(req_type, "UNKNOWN"),
                     binding.mac, iface)

        domainname = binding.domain or self.dhcp_domain
        nameservers = binding.nameservers or self.dhcp_nameservers
        domain_search = binding.domain_search or self.dhcp_domain_search

        if req_type == DHCPREQUEST and requested_addr != binding.ip:
            resp_type = DHCPNAK
            logging.info("Sending DHCPNAK to %s on %s: requested %s"
                         " instead of %s", binding.mac, iface, requested_addr,
                         binding.ip)

        elif req_type in (DHCPDISCOVER, DHCPREQUEST):
            resp_type = DHCP_REQRESP[req_type]
            resp.yiaddr = binding.ip
            dhcp_options += [
                 ("broadcast_address", str(subnet.broadcast)),
                 ("subnet_mask", str(subnet.netmask)),
                 ("renewal_time", self.dhcp_lease_renewal),
                 ("lease_time", self.dhcp_lease_lifetime),
            ]
            if binding.hostname:
                dhcp_options += [("hostname", binding.hostname)]
            if domainname:
                dhcp_options += [("domain", domainname)]
            if subnet.gw:
                dhcp_options += [("router", subnet.gw)]
            if binding.mtu:
                dhcp_options += [("interface_mtu", binding.mtu)]
            dhcp_options += [("name_server", x) for x in nameservers]
            dhcp_options += [("domain_search", format_domain_search(x))
                             for x in domain_search]

        elif req_type == DHCPINFORM:
            resp_type = DHCP_REQRESP[req_type]
            if binding.hostname:
                dhcp_options += [("hostname", binding.hostname)]
            if domainname:
                dhcp_options += [("domain", domainname)]
            dhcp_options += [("name_server", x) for x in nameservers]
            dhcp_options += [("domain_search", format_domain_search(x))
                             for x in domain_search]

        elif req_type == DHCPRELEASE:
            # Log and ignore
            logging.info("DHCPRELEASE from %s on %s", binding.mac, iface)
            return

        # Finally, always add the server identifier and end options
        dhcp_options += [
            ("message-type", resp_type),
            ("server_id", binding.dhcp_server_ip or\
                          self.dhcp_server_ip or\
                          (binding.nameservers and binding.nameservers[0]) or\
                          binding.ip),
            "end"
        ]
        resp /= DHCP(options=dhcp_options)

        logging.info("%s to %s (%s) on %s", DHCP_TYPES[resp_type], mac,
                     binding.ip, iface)
        self.sendp(resp, iface)

    def dhcp6_response(self, i, payload): # pylint: disable=W0613,R0914
        """ Generate a reply to a DHCPv6 request

        """
        # If the packet comes from a bridged interface, use the ifindex
        # of the physical device instead of the ifindex of the bridge interface
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            # We don't know anything about this interface, so accept the packet
            # and return
            logging.debug("Ignoring DHCPv6 request on unknown iface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Decode the response - NFQUEUE relays IPv6 packets
        pkt = IPv6(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        if not UDP in pkt:
            logging.warn("Invalid request on %s, no UDP"
                         " payload found", iface)
            return

        if not DHCP6_InfoRequest in pkt:
            logging.warn("Invalid request on %s, no DHCP6_InfoRequest"
                         " payload found", iface)
            return

        if not DHCP6OptClientId in pkt:
            logging.warn("Invalid request on %s, no DHCP6OptClientId"
                         " payload found", iface)
            return

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return
        ifll = str(make_ll64(ifmac))

        resp = Ether(src=ifmac, dst=binding.mac)/\
               IPv6(src=ifll, dst=pkt.src)/\
               UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)/\
               DHCP6_Reply(trid=pkt[DHCP6_InfoRequest].trid)/\
               DHCP6OptClientId(duid=pkt[DHCP6OptClientId].duid)/\
               DHCP6OptServerId(duid=DUID_LLT(lladdr=ifmac, timeval=time.time()))

        nameservers = binding.nameservers6 or self.ipv6_nameservers
        if nameservers:
            resp /= DHCP6OptDNSServers(dnsservers=nameservers)

        domain_search = binding.domain_search or self.dhcp_domain_search
        if domain_search:
            resp /= DHCP6OptDNSDomains(dnsdomains=domain_search)

        hostname_optcode = self.dhcp6_hostname_optcode \
                           if binding.dhcp6_hostname_optcode is None \
                           else binding.dhcp6_hostname_optcode
        if (hostname_optcode > 0) and binding.hostname:
            resp /= DHCP6OptUnknown(optcode=hostname_optcode,
                                    data=binding.hostname)

        domainname_optcode = self.dhcp6_domainname_optcode \
                             if binding.dhcp6_domainname_optcode is None \
                             else binding.dhcp6_domainname_optcode
        domainname = binding.domain or self.dhcp_domain
        if (domainname_optcode > 0) and domainname:
            resp /= DHCP6OptUnknown(optcode=domainname_optcode,
                                    data=domainname)

        logging.info("DHCPv6 reply to %s (%s) on %s",
                     binding.mac, pkt.src, iface)
        self.sendp(resp, iface)

    def rs_response(self, i, payload): # pylint: disable=W0613
        """ Generate a reply to an ICMPv6 router solicitation

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            logging.debug("Ignoring router solicitation on"
                          " unknown interface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        subnet = self.v6nets[iface]
        ifll = make_ll64(ifmac)

        resp = Ether(dst=binding.mac, src=ifmac)/\
               IPv6(src=str(ifll))/ICMPv6ND_RA(routerlifetime=14400)/\
               ICMPv6NDOptPrefixInfo(
                    prefix=subnet.gw or str(subnet.prefix),
                    prefixlen=subnet.prefixlen,
                    R=1 if subnet.gw else 0)

        nameservers = binding.nameservers6 or self.ipv6_nameservers
        if nameservers:
            resp /= ICMPv6NDOptRDNSS(dns=nameservers,
                                     lifetime=self.ra_period * 3)

        domain_search = binding.domain_search or self.dhcp_domain_search
        if domain_search:
            search = ''.join([format_domain_search(d)
                              for d in domain_search])
            search += ('\0' * 8)[:-len(search)%8]
            resp /= ICMPv6NDOptDNSSL(search=search,
                                     lifetime=self.ra_period * 3)

        if binding.mtu:
            resp /= ICMPv6NDOptMTU(mtu=binding.mtu)

        logging.info("RA on %s for %s", iface, subnet.net)
        self.sendp(resp, iface)

    def ns_response(self, i, payload): # pylint: disable=W0613
        """ Generate a reply to an ICMPv6 neighbor solicitation

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            logging.debug("Ignoring neighbour solicitation on"
                          " unknown interface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            payload.set_verdict(nfqueue.NF_DROP)
            return

        ns = IPv6(payload.get_data())

        if not ICMPv6ND_NS in ns:
            logging.warn("Invalid request on %s, no ICMPv6ND_NS"
                         " payload found", iface)
            payload.set_verdict(nfqueue.NF_DROP)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            payload.set_verdict(nfqueue.NF_DROP)
            return
        ifll = str(make_ll64(ifmac))

        tgt = ns[ICMPv6ND_NS].tgt
        stgt = str(tgt)

        subnet = self.v6nets[iface]

        if (stgt == (binding.dns_server_ip6 or \
                     self.dns_server_ip6 or \
                     (binding.nameservers6 and binding.nameservers6[0]) or \
                     # not ideal but no other address configured
                     binding.ip6)) or \
           (stgt == binding.notify_ip6) or \
           ((stgt == ifll) and binding.gateway6_mac):
            payload.set_verdict(nfqueue.NF_DROP)

            lladdr=binding.gateway6_mac if stgt == ifll else ifmac
            resp = Ether(src=ifmac, dst=binding.mac)/\
                   IPv6(src=ifll, dst=ns.src)/\
                   ICMPv6ND_NA(R=1, O=0, S=1, tgt=tgt)/\
                   ICMPv6NDOptDstLLAddr(lladdr=lladdr)

            logging.info("NA on %s for %s from %s: %s", iface, tgt, ns.src, lladdr)
            self.sendp(resp, iface)
        elif subnet.net.overlaps(tgt):
            logging.debug("Received NS for an IP on this subnet (%s)", stgt)
            if binding.ip6:
                logging.debug("Setting source to %s", binding.ip6)
                ns.src = binding.ip6
                del ns.cksum
                del ns[ICMPv6ND_NS].cksum
                payload.set_verdict_modified(nfqueue.NF_ACCEPT, str(ns), len(ns))
            else:
                payload.set_verdict(nfqueue.NF_ACCEPT)
        else:
            logging.debug("Dropping NS for an IP not on this subnet (%s)", stgt)
            payload.set_verdict(nfqueue.NF_DROP)

    def _dns_response(self, i, payload, ipv6): # pylint: disable=W0613,R0914
        """ Generate a reply to a DNS query

        """
        ingress = False
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            outdev = payload.get_physoutdev() or payload.get_outdev()
            try:
                iface = self.ifaces[outdev]
                ingress = True
            except KeyError:
                # We don't know anything about this interface,
                # so accept the packet and return
                logging.debug("Ignoring DNS request on unknown iface %d/%d", indev, outdev)
                # We don't know what to do with this packet, so let the kernel
                # handle it
                payload.set_verdict(nfqueue.NF_ACCEPT)
                return

        # Decode the response - NFQUEUE relays IP packets
        pkt = (IPv6 if ipv6 else IP)(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        ifmac = self.get_iface_hw_addr(iface)
        if not ifmac:
            return

        if not UDP in pkt:
            logging.warn("Invalid request from %s on %s, no UDP"
                         " payload found", binding.mac, iface)
            return

        if not DNS in pkt:
            logging.warn("Invalid request from %s on %s, no DNS"
                         " payload found", binding.mac, iface)
            return

        if not DNSQR in pkt:
            logging.warn("Invalid request from %s on %s, no DNSQR"
                         " payload found", binding.mac, iface)
            return

        if ipv6:
            resp = Ether(src=binding.mac if ingress else ifmac,
                         dst="ff:ff:ff:ff:ff:ff" if ingress else binding.mac)
            resp /= IPv6(src=binding.ip6 if ingress else\
                             (binding.dns_server_ip6 or\
                              self.dns_server_ip6 or\
                              (binding.nameservers6 and binding.nameservers6[0]) or\
                              binding.ip6),
                         dst=pkt.src)
        else:
            resp = Ether(src=binding.mac,
                         dst="ff:ff:ff:ff:ff:ff" if ingress else binding.mac)
            resp /= IP(src=binding.ip if ingress else\
                           (binding.dns_server_ip or\
                            self.dns_server_ip or\
                            (binding.nameservers and binding.nameservers[0]) or\
                            binding.ip),
                       dst=pkt.src if ingress else binding.ip)

        resp /= UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)

        qname = pkt[DNSQR].qname
        qtype = pkt[DNSQR].qtype
        qtypename = scapy_dns.dnsqtypes.get(qtype)
        addr = None
        attr = None

        if qtypename == "A":
            attr = "addresses"
        elif qtypename == "AAAA":
            attr = "addresses6"
        elif qtypename == "TXT":
            attr = "txts"
        elif qtypename == "PTR":
            pass
        else:
            logging.warn("Unsupported request for %s type %s from %s on %s",
                         qname, qtypename, binding.mac, iface)

        if attr is not None:
            # first look in binding
            addr = getattr(binding, attr).get(qname)
            if addr is None:
                # look in all address lists specified by the binding
                for alname in binding.address_lists:
                    al = self.address_lists.get("address_list_" + alname)
                    if al is not None:
                        addr = getattr(al, attr).get(qname)
                        if addr is not None:
                            break
            if addr is None:
                # look in global config
                addr = getattr(self, attr).get(qname)

        if (addr is not None):
            ttl=binding.dns_ttl or self.dns_ttl
            if (qtypename == "TXT"):
                addr = ''.join([(chr(len(l)) + l) for l in
                                iter(partial(StringIO(addr).read, 255), '')])

        if ((attr is not None) or (qtypename == "PTR")) and \
           (addr is None) and\
           self.dns_forward and\
           (binding.dns_forward is not False) and\
           can_forward(binding.no_forward, qname) and\
           (not next((al for al in binding.address_lists if
                      ("address_list_" + al) in self.address_lists and \
                      can_forward(self.address_lists["address_list_" + al].no_forward, qname)), None)) and\
           can_forward(self.no_forward, qname):
            logging.debug("Performing DNS lookup for %s type %s from %s on %s",
                          qname, qtypename, pkt.src, iface)
            try:
                # getaddrinfo doesn't support TXT queries
                #info = socket.getaddrinfo(qname, None,
                #    socket.AF_INET if qtypename == "A" else socket.AF_INET6)
                #if info:
                #    addr = info[0][4][0]
                nameservers = []
                if self.dns_nameservers:
                    nameservers += self.dns_nameservers
                if self.dns_nameservers6:
                    nameservers += self.dns_nameservers6
                if binding.dns_nameservers:
                    nameservers += binding.dns_nameservers
                if binding.dns_nameservers6:
                    nameservers += binding.dns_nameservers6
                if nameservers:
                    rvr = resolver.Resolver(configure=False)
                    rvr.nameservers = nameservers
                    info = rvr.query(qname, qtypename)
                else:
                    info = resolver.query(qname, qtypename)
                if info and len(info) > 0:
                    ttl = info.ttl
                    if qtypename == "TXT":
                        output = StringIO()
                        info[0].to_wire(output)
                        addr = output.getvalue()
                        output.close()
                    elif qtypename == "PTR":
                        addr = info[0].to_text()
                    else:
                        addr = info[0].address
            except DNSException, e:
                logging.warn("DNS lookup for %s type %s failed "
                             "from %s on %s: %s/%s",
                             qname, qtypename, pkt.src, iface, type(e), e)

        if addr:
            resp /= DNS(id=pkt[DNS].id, qr=1, aa=1, ra=1,
                        qd=pkt[DNSQR],
                        an=DNSRR(rrname=qname,
                                 rdata=addr,
                                 type=qtype,
                                 ttl=ttl))
        else:
            resp /= DNS(id=pkt[DNS].id, qr=1, aa=1,
                        qd=pkt[DNSQR],
                        rcode='name-error')

        logging.info("DNS %s->%s to %s (%s) on %s",
                     qname, repr(addr), resp[IPv6 if ipv6 else IP].dst,
                     resp[Ether].dst, iface)

        self.sendp(resp, binding.bridge if ingress and binding.bridge else iface)

    def dns_response(self, i, payload): # pylint: disable=W0613,R0914
        self._dns_response(i, payload, False)

    def dns6_response(self, i, payload): # pylint: disable=W0613,R0914
        self._dns_response(i, payload, True)

    def _notify_handle(self, i, payload, ipv6): # pylint: disable=W0613
        """ Handle a notify packet

        """
        indev = payload.get_physindev() or payload.get_indev()
        try:
            # Get the actual interface from the ifindex
            iface = self.ifaces[indev]
        except KeyError:
            # We don't know anything about this interface, so accept the packet
            # and return
            logging.debug("Ignoring notify request on unknown iface %d", indev)
            # We don't know what to do with this packet, so let the kernel
            # handle it
            payload.set_verdict(nfqueue.NF_ACCEPT)
            return

        # Decode the response - NFQUEUE relays IP packets
        pkt = (IPv6 if ipv6 else IP)(payload.get_data())

        # Signal the kernel that it shouldn't further process the packet
        payload.set_verdict(nfqueue.NF_DROP)

        try:
            binding = self.clients[self.rev_clients[iface]]
        except KeyError:
            logging.warn("No client on %s", iface)
            return

        if not Raw in pkt:
            logging.warn("Invalid request from %s on %s, no Raw"
                         " payload found", binding.mac, iface)
            return

        binding.seq_in = pkt[Raw].load

        logging.debug("Notify from %s (%s) on %s: %s",
                      binding.mac, pkt.src, iface, hexlify(binding.seq_in))

    def notify_handle(self, i, payload):
        self._notify_handle(i, payload, False)

    def notify6_handle(self, i, payload):
        self._notify_handle(i, payload, True)

    def send_periodic_ra(self):
        # Use a separate thread as this may take a _long_ time with
        # many interfaces and we want to be responsive in the mean time
        threading.Thread(target=self._send_periodic_ra).start()

    def _send_periodic_ra(self):
        logging.debug("Sending out periodic RAs")
        start = time.time()
        i = 0
        for client in self.clients.values():
            iface = client.iface
            ifmac = self.get_iface_hw_addr(iface)
            if not ifmac:
                continue

            subnet = self.v6nets[iface]
            if subnet.net is None:
                logging.debug("Skipping periodic RA on interface %s,"
                              " as it is not IPv6-connected", iface)
                continue

            ifll = make_ll64(ifmac)
            resp = Ether(src=ifmac)/\
                   IPv6(src=str(ifll))/ICMPv6ND_RA(routerlifetime=14400)/\
                   ICMPv6NDOptPrefixInfo(
                        prefix=subnet.gw or str(subnet.prefix),
                        prefixlen=subnet.prefixlen,
                        R=1 if subnet.gw else 0)

            nameservers = client.nameservers6 or self.ipv6_nameservers
            if nameservers:
                resp /= ICMPv6NDOptRDNSS(dns=nameservers,
                                         lifetime=self.ra_period * 3)

            domain_search = client.domain_search or self.dhcp_domain_search
            if domain_search:
                search = ''.join([format_domain_search(d)
                                  for d in domain_search])
                search += ('\0' * 8)[:-len(search)%8]
                resp /= ICMPv6NDOptDNSSL(search=search,
                                         lifetime=self.ra_period * 3)

            if client.mtu:
                resp /= ICMPv6NDOptMTU(mtu=client.mtu)

            try:
                self.sendp(resp, iface)
            except socket.error, e:
                logging.warn("Periodic RA on %s failed: %s", iface, str(e))
            except Exception, e:
                logging.warn("Unkown error during periodic RA on %s: %s",
                             iface, str(e))
            i += 1
        logging.debug("Sent %d RAs in %.2f seconds", i, time.time() - start)

    def send_periodic_notify(self):
        # Use a separate thread as this may take a _long_ time with
        # many interfaces and we want to be responsive in the mean time
        threading.Thread(target=self._send_periodic_notify).start()

    def _send_periodic_notify(self):
        logging.debug("Sending out periodic notifications")
        start = time.time()
        i = 0
        for client in self.clients.values():
            if client.seq_in != client.seq_out:
                self.notify_bindings([client], False)
                i += 1
        logging.debug("Sent %d notifications in %.2f seconds", i, time.time() - start)

    def serve(self):
        """ Safely perform the main loop, freeing all resources upon exit

        """
        try:
            self._serve()
        finally:
            self._cleanup()

    def _serve(self):
        """ Loop forever, serving DHCP requests

        """
        self.build_config()

        # Yes, we are accessing _fd directly, but it's the only way to have a
        # single select() loop ;-)
        iwfd = self.notifier._fd # pylint: disable=W0212

        start = time.time()
        max_timeout = None

        if self.ipv6_enabled:
            max_timeout = self.ra_period
            self.send_periodic_ra()

        if self.notify_enabled:
            max_timeout = self.notify_period if max_timeout is None else \
                          min(self.notify_period, max_timeout)
            self.send_periodic_notify()

        timeout = max_timeout

        while True:
            try:
                rlist, _, xlist = select.select(self.nfq.keys() + [iwfd], [], [], timeout)
            except select.error, e:
                if e[0] == errno.EINTR:
                    logging.debug("select() got interrupted")
                    continue

            if xlist:
                logging.warn("Warning: Exception on %s",
                             ", ".join([str(fd) for fd in xlist]))

            if rlist:
                if iwfd in rlist:
                # First check if there are any inotify (= configuration change)
                # events
                    self.notifier.read_events()
                    self.notifier.process_events()
                    rlist.remove(iwfd)

                for fd in rlist:
                    try:
                        self.nfq[fd].process_pending()
                    except RuntimeError, e:
                        logging.warn("Error processing fd %d: %s", fd, str(e))
                    except Exception, e:
                        logging.warn("Unknown error processing fd %d: %s",
                                     fd, str(e))

            if max_timeout is not None:
                # Calculate the new timeout
                timeout = max_timeout - (time.time() - start)

                if timeout <= 0:
                    start = time.time()
                    if self.ipv6_enabled:
                        self.send_periodic_ra()
                    if self.notify_enabled:
                        self.send_periodic_notify()
                    timeout = max_timeout - (time.time() - start)

    def print_clients(self):
        logging.info("%10s   %20s %20s %10s %20s %40s",
                     'Key', 'Client', 'MAC', 'IFACE', 'IP', 'IPv6')
        for k, cl in self.clients.items():
            logging.info("%10s | %20s %20s %10s %20s %40s",
                         k, cl.hostname, cl.mac, cl.iface, cl.ip, cl.ip6)


if __name__ == "__main__":
    import capng
    import optparse
    from cStringIO import StringIO
    from pwd import getpwnam, getpwuid
    from configobj import ConfigObj, ConfigObjError, flatten_errors

    import validate

    validator = validate.Validator()

    def is_ip_list(value, family=4):
        try:
            family = int(family)
        except ValueError:
            raise validate.VdtParamError(family)
        if isinstance(value, (str, unicode)):
            value = [value]
        if not isinstance(value, list):
            raise validate.VdtTypeError(value)

        for entry in value:
            try:
                ip = IPy.IP(entry)
            except ValueError:
                raise validate.VdtValueError(entry)

            if ip.version() != family:
                raise validate.VdtValueError(entry)
        return value

    def is_ip6_addr(value):
        try:
            ip = IPy.IP(value)
        except ValueError:
            raise validate.VdtValueError(value)

        if ip.version() != 6:
            raise validate.VdtValueError(value)

        return value

    validator.functions["ip_addr_list"] = is_ip_list
    validator.functions['ip6_addr'] = is_ip6_addr
    config_spec = StringIO(CONFIG_SPEC)


    parser = optparse.OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
                      help="The location of the data files", metavar="FILE",
                      default=DEFAULT_CONFIG)
    parser.add_option("-d", "--debug", action="store_true", dest="debug",
                      help="Turn on debugging messages")
    parser.add_option("-f", "--foreground", action="store_false",
                      dest="daemonize", default=True,
                      help="Do not daemonize, stay in the foreground")


    opts, args = parser.parse_args()

    try:
        config = ConfigObj(opts.config_file, configspec=config_spec)
    except ConfigObjError, err:
        sys.stderr.write("Failed to parse config file %s: %s" %
                         (opts.config_file, str(err)))
        sys.exit(1)

    results = config.validate(validator)
    if results != True:
        logging.fatal("Configuration file validation failed! See errors below:")
        for (section_list, key, unused) in flatten_errors(config, results):
            if key is not None:
                logging.fatal(" '%s' in section '%s' failed validation",
                              key, ", ".join(section_list))
            else:
                logging.fatal(" Section '%s' is missing",
                              ", ".join(section_list))
        sys.exit(1)

    try:
        uid = getpwuid(config["general"].as_int("user"))
    except ValueError:
        uid = getpwnam(config["general"]["user"])

    # Keep only the capabilities we need
    # CAP_NET_ADMIN: we need to send nfqueue packet verdicts to a netlinkgroup
    # CAP_NET_RAW: we need to reopen socket in case the buffer gets full
    # CAP_SETPCAP: needed by capng_change_id()
    capng.capng_clear(capng.CAPNG_SELECT_BOTH)
    capng.capng_update(capng.CAPNG_ADD,
                       capng.CAPNG_EFFECTIVE|capng.CAPNG_PERMITTED,
                       capng.CAP_NET_ADMIN)
    capng.capng_update(capng.CAPNG_ADD,
                       capng.CAPNG_EFFECTIVE|capng.CAPNG_PERMITTED,
                       capng.CAP_NET_RAW)
    capng.capng_update(capng.CAPNG_ADD,
                       capng.CAPNG_EFFECTIVE | capng.CAPNG_PERMITTED,
                       capng.CAP_SETPCAP)

    # change uid
    capng.capng_change_id(uid.pw_uid, uid.pw_gid,
                          capng.CAPNG_DROP_SUPP_GRP|capng.CAPNG_CLEAR_BOUNDING)

    logger = logging.getLogger()
    if opts.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    if opts.daemonize:
        logfile = os.path.join(config["general"]["logdir"], LOG_FILENAME)
        handler = logging.handlers.RotatingFileHandler(logfile,
                                                       maxBytes=2097152,
                                                       backupCount=5)
    else:
        handler = logging.StreamHandler()

    handler.setFormatter(logging.Formatter(LOG_FORMAT))
    logger.addHandler(handler)

    if opts.daemonize:
        pidfile = daemon.pidlockfile.TimeoutPIDLockFile(
            config["general"]["pidfile"], 10)
        # Remove any stale PID files, left behind by previous invocations
        if daemon.runner.is_pidfile_stale(pidfile):
            logger.warning("Removing stale PID lock file %s", pidfile.path)
            pidfile.break_lock()

        d = daemon.DaemonContext(pidfile=pidfile,
                                 umask=0022,
                                 stdout=handler.stream,
                                 stderr=handler.stream,
                                 files_preserve=[handler.stream])
        try:
            d.open()
        except (daemon.pidlockfile.AlreadyLocked, LockTimeout):
            logger.critical("Failed to lock pidfile %s,"
                            " another instance running?", pidfile.path)
            sys.exit(1)

    logging.info("Starting up")
    logging.info("Running as %s (uid:%d, gid: %d)",
                  config["general"]["user"], uid.pw_uid, uid.pw_gid)

    proxy_opts = {}
    if config["dhcp"].as_bool("enable_dhcp"):
        proxy_opts.update({
            "dhcp_queue_num": config["dhcp"].as_int("dhcp_queue"),
            "dhcp6_queue_num": config["dhcp"].as_int("dhcp6_queue"),
            "dhcp_lease_lifetime": config["dhcp"].as_int("lease_lifetime"),
            "dhcp_lease_renewal": config["dhcp"].as_int("lease_renewal"),
            "dhcp6_hostname_optcode": config["dhcp"].as_int("dhcp6_hostname_optcode"),
            "dhcp6_domainname_optcode": config["dhcp"].as_int("dhcp6_domainname_optcode"),
            "dhcp_server_ip": config["dhcp"]["server_ip"],
            "dhcp_nameservers": config["dhcp"]["nameservers"],
            "dhcp_domain": config["dhcp"]["domain"],
            "dhcp_domain_search": config["dhcp"]["domain_search"],
        })

    if config["ipv6"].as_bool("enable_ipv6"):
        proxy_opts.update({
            "rs_queue_num": config["ipv6"].as_int("rs_queue"),
            "ns_queue_num": config["ipv6"].as_int("ns_queue"),
            "ra_period": config["ipv6"].as_int("ra_period"),
            "ipv6_nameservers": config["ipv6"]["nameservers"],
        })

    if config["dns"].as_bool("enable_dns"):
        proxy_opts.update({
            "dns_queue_num": config["dns"].as_int("dns_queue"),
            "dns6_queue_num": config["dns"].as_int("dns6_queue"),
            "dns_server_ip": config["dns"]["server_ip"],
            "dns_server_ip6": config["dns"]["server_ip6"],
            "dns_ttl": config["dns"]["ttl"],
            "dns_forward": config["dns"]["forward"],
            "addresses": config["addresses"],
            "addresses6": config["addresses6"],
            "txts": config["txts"],
            "no_forward": config["dns"]["no_forward"],
            "dns_nameservers": config["dns"]["nameservers"],
            "dns_nameservers6": config["dns"]["nameservers6"]
        })

    if config["notify"].as_bool("enable_notify"):
        proxy_opts.update({
            "notify_queue_num": config["notify"].as_int("notify_queue"),
            "notify6_queue_num": config["notify"].as_int("notify6_queue"),
            "notify_period": config["notify"].as_int("notify_period"),
        })

    # pylint: disable=W0142
    proxy = VMNetProxy(data_path=config["general"]["datapath"], **proxy_opts)

    logging.info("Ready to serve requests")

    def debug_handler(signum, _):
        logging.debug('Received signal %d. Printing proxy state...', signum)
        proxy.print_clients()

    # Set the signal handler for debuging clients
    signal.signal(signal.SIGUSR1, debug_handler)
    signal.siginterrupt(signal.SIGUSR1, False)

    try:
        proxy.serve()
    except Exception:
        if opts.daemonize:
            exc = "".join(traceback.format_exception(*sys.exc_info()))
            logging.critical(exc)
        raise


# vim: set ts=4 sts=4 sw=4 et :
